기본적인 시큐리티 프로그램 연습을 하기 위해 start.spring.io를 들어가 세팅을 해야한다. 
Dependencies에 Spring Web, Spring Boot DevTools, Lombok, Mysql Driver, Spring Security, Mustache, Spring Data JPA를 사용했다. 

application.properties -> application.yml
application파일은 프로그램을 실행시키고, 웹의 요청과 응답등 모든 과정에서 항상 적용되는 부분이다. 
이렇게 디펜던시 설정을 해주고 나서, 기본적으로 main/resources/templates/에 application.properties 파일이 있다. 이 파일의
확장자를 application.yml로 바꾸어 주고, 그 안에 몇가지를 입력할 것이다. 

먼저 server에 관한 내용을 보자면, port에  localhost:****에서 별 4자리 수를 입력해주면 된다. 개인의 자유이다. 
이후 servlet을 설정해주는데, 이 servlet은 요청에 따른 메서드 호출을 편하게 해주는 자바의 웹 프로그래밍 기술이다. 
이 속에 context-path, encoding을 입력해야 하는데, context-path는 /하나를 넣어준다. 
이 뜻은 받아들이는 웹 주소의 구분을 /단위로 찾아서 이동한다는 뜻이다. 

이후 encoding은 파일의 저장 형식, 파일을 보여줄 때 어떻게 보여줄 지를 결정한다. 
첫번째로 enabled는 http의 인코딩 지원 가능성을 설정해주는 것이며, 그 다음 charset은 인코딩 방식을 설정하는 것으로, UTF-8을 이용한다. 
마지막에 있는 force는 http의 요청과 응답에서 encoding이 설정된 charset을 항상 적용시키게 지키라고 하는 것이다. 

이후 spring부분을 볼 것인데, 이 때 spring상에서 적용되어야 할 부분을 작성해야 하며, 이 때 datasource를 내부에서 설정할 것이다. 
datasource는 db서버와의 연결을 해 db에서 정보를 가져오거나, 정보를 받아와 db에 넣을 수 있게 설정해주는 것이다. 
내부에 driver-class-name을 설정해준다. 이는 db에 접근할 때 사용하는 jdbc driver의 클래스명을 적는 것이다. 
다음으로 username 부분에 db에 요청하기 위한 db상의 사용자명, password는 그 사용자의 비밀번호를 넣는다. 
url에는 jdbc에서 연결할 호스트명, 포트번호, 스키마 등이 들어간다.
예시로 이 파일에 적혀있는 jdbc:mysql://localhost:3306/security?serverTimezone=Asia/Seoul를 보자면, 
jdbc를 통해 mysql을 이용할 것이며, 사용자는 localhost, 포트번호는 3306(로컬주소)이고, 스키마의 이름은 security이다. 
? 뒤에 있는 부분은 서버의 타임을 정해주는 것이다. 

마지막으로 jpa를 보자면, 내부에 hibernate, show-sql이 있다. 
jpa는 자바에서 기술표준으로 쓰는 인터페이스 모음이다. 이를 통해 객체 관계를 더 쉽게 매핑할 수 있고, 객체 중심으로 개발 할 수 있게 해준다. 
이 중 hibernate는 자바를 위한 객체 관계 프레임워크 이름이다. 우리가 jpa를 통해 사용하는 객체 모델을 관계형 데이터베이스와 매핑시켜준다. 
Hibernate 내부에 naming이 들어가는데 그 안에 보면 physical-strategy가 있다. 
데이터베이스를 배우다보면, 논리적 데이터 모델과 물리적 데이터 모델이 있다. 물리는 쉽게 보면 mysql에서 보는 테이블의 형태로, 이 테이블상의 이름을 만드는 방식을 설정한 것이다. 
이후 ddl-auto는 데이터베이스를 어떻게 할지를 정한다.
예시로 말하는 것이 더 쉬운데, update, create를 자주 쓰므로, 이걸 가지고 설명하자면 create는 해당 프로그램이 실행될 때 마다 테이블을 삭제후 새로 생성하는 것이고, update는 해당 데이터베이스를 가져와 그 위에 수정을 하며 계속 이용하는 것이다. 
마지막으로 show-sql은 hibernate에서 db를 이용할 때 쓰는 쿼리문(DDL데이터베이스 정의어, DML데이터베이스 조작어)을 보낼 때, 이를 우리도 볼 수 있게 해준다.

이렇게 설정이 끝났으면, Controller를 만들 것이다. 
기본적인 WEB MVC를 간단히 이해하고, controller부터 service, repository, bin이 뭔지 이해하고 있다면, GetMapping상태에서 String으로 함수를 만들어 return에 string을 하면 html파일을 보여주는 것을 알 것이다. 

이러한 방식대로 만들고, 프로그램을 실행시키면 바로 우리가 원하는 창이 아닌, /login으로 넘어간다. 이는 spring security가 기본적으로 사용자의 로그인을 요청하는 것이다. 
우리는 회원가입을 한 적이 없다. 하지만, 이를 위한 spring security의 기본 비밀번호가 있다. 콘솔을 보면,~ Using generated security password:의 뒷부분에 비밀번호가 있다. 이를 이용해 로그인 하면 다음 창으로 이동할 수 있다. 나중엔, 회원가입을 하고 이 가입된 아이디와 비밀번호를 통한 로그인도 실행시킬 것이다. 

그런데, 우리가 사용한 것은 mustache dependency이므로 .html이 아닌 .mustache이다. 
그렇다면, 일반적인 html파일이 실행되지 않는다. 실제로 실행시켜서 GetMapping에 원하는 주소를 넣고 실행시켜 들어가도 404가 뜬다. 그렇게 때문에 mustache에 대한 설정을 해줄 필요가 있다. 

그렇기 위해 WebMVCConfigurer을 implement한 Configuration을 만들어야 한다. @Configuration 어노테이션을 하는 클래스를 만들어, WebMVCConfigurer을 implement해준다. 
이후 configureViewResolver을 Override해준다. 이 때 기본적인 값을 그대로 쓰지 않고 수정해주어야 하는데, 파일의 수정된 상태를 가지고 이야기를 하자면, MustacheResolver를 가져와야 한다. 이를 통해 Mustache가 뷰를 가져올 때 이를 어떻게 가져올지, 뭘 가져올지등을 설정할 수 있다. 
MustacheResolver형 변수를 만들고, 여기에 우리가 일반적으로 html파일에 쓰는 설정들을 넣어주어야 한다. 
charset이 기본적으로 html에서 UTF-8을 썼다. 이를 마찬가지로 설정해준다. setCharset함수를 사용한다. 이를 통해 UTF-8을 이용한 인코딩을 한다.  
setContentType함수도 사용하는데, 이는 UTF-8로 인코딩을 해도 이상한 문자가 나오는, 코드 해석의 default를 맞추어 주는 것이다. 
setPrefix와 setSuffix는 묶어서 설명하자면, 파일의 이름을 알 때 앞에는 그 파일의 위치가, 뒤엔 그 파일의 확장자가 적혀있다. 
이를 우리가 파일을 넣는 주소(classpath:/templates/)와 파일에 설정된 확장자(.html)를 넣어 적용시켜 준다. 
그리고 이 MustacheResolver형 변수를 registry.viewResolver에 넣어주면 MustacheResolver도 우리가 사용하던 방식대로 작동할 수 있게 된다. 

이후 시큐리티 설정을 해주어야 하는데, 시큐리티 설정을 통해 각 계정에 권한을 부여하고, 이 권한에 맞는 사용자가 해당 페이지를 요청하는 것인지 확인하고, 권한이 있는 사용자는 보여주되, 권한이 없다면 보내지 않는 방식을 만들어야 한다. 이를 위해 /user, /manager, /admin, /login, /join, /joinProc를 컨트롤러에 만들어준다. 모두 동일한 이름의 html파일을 리턴하게 하지만, joinProc는 responsebody를 통해 "회원가입 완료"라는 글이 리턴되게 만들어둔다. 
