기본적인 시큐리티 프로그램 연습을 하기 위해 start.spring.io를 들어가 세팅을 해야한다. 
Dependencies에 Spring Web, Spring Boot DevTools, Lombok, Mysql Driver, Spring Security, Mustache, Spring Data JPA를 사용했다. 

application.properties -> application.yml
application파일은 프로그램을 실행시키고, 웹의 요청과 응답등 모든 과정에서 항상 적용되는 부분이다. 
이렇게 디펜던시 설정을 해주고 나서, 기본적으로 main/resources/templates/에 application.properties 파일이 있다. 이 파일의
확장자를 application.yml로 바꾸어 주고, 그 안에 몇가지를 입력할 것이다. 

먼저 server에 관한 내용을 보자면, port에  localhost:****에서 별 4자리 수를 입력해주면 된다. 개인의 자유이다. 
이후 servlet을 설정해주는데, 이 servlet은 요청에 따른 메서드 호출을 편하게 해주는 자바의 웹 프로그래밍 기술이다. 
이 속에 context-path, encoding을 입력해야 하는데, context-path는 /하나를 넣어준다. 
이 뜻은 받아들이는 웹 주소의 구분을 /단위로 찾아서 이동한다는 뜻이다. 

이후 encoding은 파일의 저장 형식, 파일을 보여줄 때 어떻게 보여줄 지를 결정한다. 
첫번째로 enabled는 http의 인코딩 지원 가능성을 설정해주는 것이며, 그 다음 charset은 인코딩 방식을 설정하는 것으로, UTF-8을 이용한다. 
마지막에 있는 force는 http의 요청과 응답에서 encoding이 설정된 charset을 항상 적용시키게 지키라고 하는 것이다. 

이후 spring부분을 볼 것인데, 이 때 spring상에서 적용되어야 할 부분을 작성해야 하며, 이 때 datasource를 내부에서 설정할 것이다. 
datasource는 db서버와의 연결을 해 db에서 정보를 가져오거나, 정보를 받아와 db에 넣을 수 있게 설정해주는 것이다. 
내부에 driver-class-name을 설정해준다. 이는 db에 접근할 때 사용하는 jdbc driver의 클래스명을 적는 것이다. 
다음으로 username 부분에 db에 요청하기 위한 db상의 사용자명, password는 그 사용자의 비밀번호를 넣는다. 
url에는 jdbc에서 연결할 호스트명, 포트번호, 스키마 등이 들어간다.
예시로 이 파일에 적혀있는 jdbc:mysql://localhost:3306/security?serverTimezone=Asia/Seoul를 보자면, 
jdbc를 통해 mysql을 이용할 것이며, 사용자는 localhost, 포트번호는 3306(로컬주소)이고, 스키마의 이름은 security이다. 
? 뒤에 있는 부분은 서버의 타임을 정해주는 것이다. 

마지막으로 jpa를 보자면, 내부에 hibernate, show-sql이 있다. 
jpa는 자바에서 기술표준으로 쓰는 인터페이스 모음이다. 이를 통해 객체 관계를 더 쉽게 매핑할 수 있고, 객체 중심으로 개발 할 수 있게 해준다. 
이 중 hibernate는 자바를 위한 객체 관계 프레임워크 이름이다. 우리가 jpa를 통해 사용하는 객체 모델을 관계형 데이터베이스와 매핑시켜준다. 
Hibernate 내부에 naming이 들어가는데 그 안에 보면 physical-strategy가 있다. 
데이터베이스를 배우다보면, 논리적 데이터 모델과 물리적 데이터 모델이 있다. 물리는 쉽게 보면 mysql에서 보는 테이블의 형태로, 이 테이블상의 이름을 만드는 방식을 설정한 것이다. 
이후 ddl-auto는 데이터베이스를 어떻게 할지를 정한다.
예시로 말하는 것이 더 쉬운데, update, create를 자주 쓰므로, 이걸 가지고 설명하자면 create는 해당 프로그램이 실행될 때 마다 테이블을 삭제후 새로 생성하는 것이고, update는 해당 데이터베이스를 가져와 그 위에 수정을 하며 계속 이용하는 것이다. 
마지막으로 show-sql은 hibernate에서 db를 이용할 때 쓰는 쿼리문(DDL데이터베이스 정의어, DML데이터베이스 조작어)을 보낼 때, 이를 우리도 볼 수 있게 해준다.

이렇게 설정이 끝났으면, Controller를 만들 것이다. 
기본적인 WEB MVC를 간단히 이해하고, controller부터 service, repository, bin이 뭔지 이해하고 있다면, GetMapping상태에서 String으로 함수를 만들어 return에 string을 하면 html파일을 보여주는 것을 알 것이다. 

이러한 방식대로 만들고, 프로그램을 실행시키면 바로 우리가 원하는 창이 아닌, /login으로 넘어간다. 이는 spring security가 기본적으로 사용자의 로그인을 요청하는 것이다. 
우리는 회원가입을 한 적이 없다. 하지만, 이를 위한 spring security의 기본 비밀번호가 있다. 콘솔을 보면,~ Using generated security password:의 뒷부분에 비밀번호가 있다. 이를 이용해 로그인 하면 다음 창으로 이동할 수 있다. 나중엔, 회원가입을 하고 이 가입된 아이디와 비밀번호를 통한 로그인도 실행시킬 것이다. 

그런데, 우리가 사용한 것은 mustache dependency이므로 .html이 아닌 .mustache이다. 
그렇다면, 일반적인 html파일이 실행되지 않는다. 실제로 실행시켜서 GetMapping에 원하는 주소를 넣고 실행시켜 들어가도 404가 뜬다. 그렇게 때문에 mustache에 대한 설정을 해줄 필요가 있다. 

그렇기 위해 WebMVCConfigurer을 implement한 Configuration을 만들어야 한다. @Configuration 어노테이션을 하는 클래스를 만들어, WebMVCConfigurer을 implement해준다. 
이후 configureViewResolver을 Override해준다. 이 때 기본적인 값을 그대로 쓰지 않고 수정해주어야 하는데, 파일의 수정된 상태를 가지고 이야기를 하자면, MustacheResolver를 가져와야 한다. 이를 통해 Mustache가 뷰를 가져올 때 이를 어떻게 가져올지, 뭘 가져올지등을 설정할 수 있다. 
MustacheResolver형 변수를 만들고, 여기에 우리가 일반적으로 html파일에 쓰는 설정들을 넣어주어야 한다. 
charset이 기본적으로 html에서 UTF-8을 썼다. 이를 마찬가지로 설정해준다. setCharset함수를 사용한다. 이를 통해 UTF-8을 이용한 인코딩을 한다.  
setContentType함수도 사용하는데, 이는 UTF-8로 인코딩을 해도 이상한 문자가 나오는, 코드 해석의 default를 맞추어 주는 것이다. 
setPrefix와 setSuffix는 묶어서 설명하자면, 파일의 이름을 알 때 앞에는 그 파일의 위치가, 뒤엔 그 파일의 확장자가 적혀있다. 
이를 우리가 파일을 넣는 주소(classpath:/templates/)와 파일에 설정된 확장자(.html)를 넣어 적용시켜 준다. 
그리고 이 MustacheResolver형 변수를 registry.viewResolver에 넣어주면 MustacheResolver도 우리가 사용하던 방식대로 작동할 수 있게 된다. 

이후 시큐리티 설정을 해주어야 하는데, 시큐리티 설정을 통해 각 계정에 권한을 부여하고, 이 권한에 맞는 사용자가 해당 페이지를 요청하는 것인지 확인하고, 권한이 있는 사용자는 보여주되, 권한이 없다면 보내지 않는 방식을 만들어야 한다. 이를 위해 /user, /manager, /admin, /login, /join, /joinProc를 컨트롤러에 만들어준다. 모두 동일한 이름의 html파일을 리턴하게 하지만, joinProc는 responsebody를 통해 "회원가입 완료"라는 글이 리턴되게 만들어둔다. 

하지만, /login은 responsebody를 써도 우리가 지정한대로가 아닌, 일반적인 로그인창으로 가진다. 이는 spring security에서 /login이라는 주소를 낚아채는 것임을 알 수 있다. 모든 주소를 입력해보면 404오류가 뜰 것이다. 각 리턴값에 따른 html파일이 없기 때문이다. 하지만 user는 manager나 admin을 들어갈 수 없게 해야한다. 이러한 SecurityConfiguration을 만들어 줘야한다. 


SecurityConfiguration 클래스를 만들었다면 이 클래스에 어노테이션을 등록해줘야 한다. Configuration과 EnableWebSecurity를 넣는데, 이전에도 Configuration을 사용했는데, 이 어노테이션을 단 클래스는 빈 설정을 담당하는 클래스가 된다. EnableWebSecurity 어노테이션의 용도는 스프링 시큐리티 필터를 스프링 필터 체인에 등록시켜주는 역할을 한다. 이를 통해 일련의 과정에서 시큐리티상 부적합한 것은 필터링해줄 수 있다. 
클래스에 WebSecurityConfigurerAdapter를 extends해준다. 이를 통해 오버라이드 해야될 함수가 있다. configure(HttpSecurity http)함수를 오버라이드 하면 그 안에 securityconfiguration을 통해 시큐리티가 어떻게 동작해야되는지 정할 수 있는 것이다. 
여기에 http.csrf().disable();를 입력하게 되는데, csrf는 사이트간 위조 요청인데 이를 disable한다. 굳이 이 위조요청 방지하는 방식을 끄는 이유는 시큐리티에 이번에 사용한 OAuth2나 다음 프로젝트에서 만든 jwt토큰을 이용한 인증정보를 포함시켜 실행되기 때문에 불필요한 csrf를 쓸 필요가 없는 것이다. 
다음에 있는 authorizeRequests를 통해 권한 요청을 하게 하며, 이를 위해 주소 요청을 낚아채야할 필요가 있다. 
이 때 antMathcers가 쓰이며, 이 함수를 통해 특정 주소를 넣어주면 그 주소가 들어올 때 권한확인 및 추가적인 조작을 하게 해준다. 
antMatchers("/user/**").authenticated()를 예시로 들면, user로 들어가면 권한이 있는지 확인한다. 즉 로그인 했는지 확인하는 것이다. 
그다음엔 .access가 authenticated대신에 들어가는데 이는 큰 따옴표 안에 해당사항이 있는 경우에만 허가할 떄 쓰인다. 
이를 통해 /user, /admin, /manager에서 어떻게 적동되어야 하는지를 정했다. 그 외의 경우를 위해
.anyRequest().permitAll();을 통해 그 외의 요청들을 다 허가하는 방식으로 설정하면 된다. 
이 상태에서 다시 /user, /manager, /admin을 들어가면 403오류가 뜬다. 이는 권한없음을 의미한다. 
대신 spring security에서 자체적으로 작동시키던 로그인창이 사라졌다. 이를 다시 만들어주기 위해
.and().formLogin().loginPage("/login");을 넣어 자체 로그인 폼을 /login주소가 들어올 때 띄워주게 할 수 있다. 

로그인 창을 만든걸 사용하게 했고, 이제 회원가입을 가능하게 해야 한다. 이를 위해 MVC중에 M, user을 만들어야한다. 회원가입을 할 때 이 model을 이용해 사용자 정보를 데이터베이스에 저장시키고 추가적인 회원들이 회원가입, 로그인을 가능하게 한다. 
이를 위해 로그인 창에 join을 링크로 달아주고, join.html을 만들어준다. 
이후 html을 작성해야 하는데, 이 때 login을 그대로 복사해 온 후, 약간의 수정을 해준다. Form 태그에 action, method를 넣어주아야 하는데, action은 "/joinProc", method는 "POST"로 적어준다. 
이제 회원가입정보를 POST로 받아와 컨트롤러에서 저장하는 작업을 명령한다. 이때 저장을 위해 Repository를 만들어준다. 
레포지토리에 extends JpaRepository<User, Integer>를 넣어준다. Extends를 하면 자동으로 IoC로 연결이 되어 불러와 사용이 가능하므로 레포지토리 어노테이션을 넣어줄 필요는 없지만, 보기 편하게 넣어주었다. 이제 컨트롤러에 Autowired로 레포지토리를 불러와 저장작업을 시켜주면 입력은 가능해진다.

여기서 문제는 암호가 암호화되지 않은 텍스트 자체로 저장이 된다는 것이다. 보안상의 이유로 이를 암호화 시켜 저장해주어야 한다. 
암호화를 시키기 위해서 SecurityConfig에 암호화시키는 함수를 만들어 Bean으로 쓸 것이다. 함수의 리턴 값은 암호화된 값이어야 하므로, BCryptPasswordEncoder형 함수로 리턴시에도 new BCryptPasswordEncoder()를 리턴한다. 이에 Bean어노테이션을 넣어 어디서든 쓸 수 있게 해 컨트롤러에서 불러온다. 이 함수를 이용해 user.getPassword를 암호화해 setPassword해주면 암호화된 값을 저장시킬 수 있다. 

이렇게 암호화된 비밀번호를 저장시키는 회원가입을 만들었다면, 로그인도 시킬 수 있어야 한다. 